2. Components (Responsibilities & Interfaces)

2.1 Wallet Service (Enterprise)
	•	Purpose: Custody users’/participants’ keys (or fetch from KMS) and perform EIP‑712 signing for meta‑transactions.
	•	Interfaces:
	•	POST /wallets → create wallet (optional, if not using external custody).
	•	POST /sign/eip712 → body: {domain, types, message}; returns {signature}.
	•	Notes: Can proxy to KMS for signing; never exposes private keys.

2.2 SLE Backend API (Enterprise)
	•	Purpose: Orchestrates business flows; builds meta‑tx payloads; calls Paladin Relayer API.
	•	Interfaces: Internal RPC/HTTP handlers; outbound to Paladin Relayer:
	•	POST /relayer/mint
	•	POST /relayer/burn
	•	Security: mTLS client cert + JWT/HMAC to Relayer.

2.3 AWS KMS (Enterprise)
	•	Purpose: HSM‑backed key storage/signing for enterprise accounts and, optionally, gas‑sponsor keys.
	•	Interfaces: KMS Sign, GetPublicKey; algorithm ECDSA_secp256k1 (or via external plugin).

2.4 RelayerSigner (Enterprise)
	•	Purpose: Utility service to assemble and serialize transactions; attaches sponsor signature only if gasPrice ≠ 0; RLP encodes and submits to JSON‑RPC.
	•	Interfaces: POST /tx/build, POST /tx/send.
	•	Notes: In gasPrice = 0 mode, it forwards the meta‑tx without sponsor signing.

2.5 Paladin Relayer (SLE)
	•	Purpose: Single bridge‑facing component (edge). Admits requests, validates user EIP‑712 signatures off‑chain, applies quotas, and submits to Paladin RPC.
	•	Interfaces (external to Enterprise over mTLS):
	•	POST /v1/mint → {payload, userSignature, nonce, deadline, …}
	•	POST /v1/burn → {payload, userSignature, nonce, deadline, …}
	•	GET  /v1/requests/{id} → status, paladinTxHash, receipts.
	•	Security: mTLS clientAuth, IP allow‑list, JWT/HMAC, replay window (nonce+timestamp), rate‑limit per client DN.
	•	Persistence: Writes audit records to Database.

2.6 Issuer Bridge Operator (SLE) (only if using the “Trusted Bridge” variant)
	•	Purpose: Listens to Enterprise on‑chain events and calls Issuer Notary/Relayer.
	•	If your latest model is Relayer‑only, you can omit this component.

2.7 Paladin RPC Node / Issuer Paladin RPC Node (SLE)
	•	Purpose: EVM execution for Privacy Groups (Noto + Hooks + Notary wiring).
	•	Interfaces: JSON‑RPC (eth_sendRawTransaction, eth_call, eth_getTransactionReceipt).

2.8 Linea RPC Node (optional)
	•	Purpose: If the flow needs L2 interactions or anchoring.

2.9 Database (SLE)
	•	Purpose: Durable, tamper‑evident audit: {requestId, clientDn, user, nonce, deadline, method, paramsHash, paladinTxHash, status, timestamps





#####
Low Level Design (LLD) – SLE Solution
1. Introduction

This document describes the Low Level Design (LLD) of the SLE Solution. It details each component, their responsibilities, and the interactions between services, relayers, smart contracts, and external systems. The goal is to provide developers with a clear, technical implementation view.

2. Diagram

(Include the diagram you showed: SLE Design Solution – Component Implementation)

3. Component Responsibilities
Component Name	Description	Interfaces / Dependencies
SLE Backend API	Provides REST endpoints for enterprise apps to interact with blockchain components. Handles validation, orchestration, and persistence.	REST APIs, Database, Paladin Relayer
SLE Controller	Manages business logic for enterprise flows (transactions, balances).	Invokes SLE Services
SLE Service	Implements use cases (e.g., mint, transfer, query).	SLE DAO/Repository, Paladin Relayer
SLE DAO/Repository	Provides persistence layer and access to off-chain data.	Database
Paladin Relayer Service	Intermediary between backend and blockchain. Converts API calls into signed blockchain transactions.	Web3 SDK, Besu RPC
Paladin Controller / Service	Implements relayer operations such as signing, nonce handling, and submission.	Paladin SDK
Issuer Bridge Operator	Responsible for interoperability with external networks. Executes bridge transactions.	BridgeOperator Service, Web3
Bridge Contracts	Smart contracts deployed on-chain for asset transfer and message passing.	Besu RPC
Paladin Contracts	Smart contracts for privacy groups, tokenization, and private balance queries.	Besu RPC
ERC Tokens	Standard ERC-20/721/1155 assets for fungible and non-fungible representation.	Blockchain APIs
Database	Stores off-chain data, metadata, and historical records.	SQL/NoSQL interface
4. Component Implementation
4.1 SLE Backend Application

Controllers: Handle API requests (e.g., TransactionController, BalanceController).

Services: Implement business flows (e.g., TransferService, BalanceService).

DAO/Repository: Interfaces with database for persistence.

Interfaces: REST endpoints (/api/v1/...), DB queries, calls Paladin Relayer.

4.2 Paladin Relayer Service

Responsibilities:

Accepts requests from SLE Backend.

Prepares raw transactions and signs with private key (HSM/KMS).

Submits to Besu RPC.

Interfaces: REST API, Web3 SDK.

4.3 Issuer Bridge Operator

Responsibilities:

Connects SLE network with external (SWIFT/Linea) networks.

Executes mint/burn on both sides.

Interfaces: BridgeOperator Service, Web3, Bridge Contracts.

4.4 Smart Contracts

ERC Tokens – implement standard token logic.

Paladin Contracts – support private transactions, tokenization, and privacy groups.

Bridge Contracts – implement message passing and asset transfer.

5. Data Flow (Example: Get Private Balance)

User calls SLE Backend API (/balance/private).

SLE Controller → Service → Paladin Relayer.

Paladin Relayer builds Web3 call to Paladin Contract.

Smart contract returns balance, relayer sends result back to backend.

Backend responds to client.
