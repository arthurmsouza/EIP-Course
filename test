4.2.2.2 Backend API

The Backend API, built on Spring Boot, is the orchestration hub for all business processes. Beyond request validation and persistence, it is directly responsible for preparing and submitting blockchain transactions. To do so, the Backend API invokes the WalletConfigHelper to retrieve the appropriate signing key or account configuration. This ensures separation of concerns between transaction orchestration and key management.

Once a transaction is prepared, the Backend API calls the RelayerHelper to handle signing and submission to the RPC node. Smart contract functions are invoked via ABI-encoded payloads generated by the Backend API, ensuring that business workflows are consistently enforced on-chain. In the prototype, these responsibilities remain centralized in the Backend API, with helpers annotated as @Component to allow seamless refactoring into standalone services in later phases.

⸻

4.2.2.3 Relayer Service (Next Phase)

The Relayer Service ensures reliable and nonce-safe submission of transactions to the blockchain network. It encapsulates low-level responsibilities such as transaction signing, nonce management, gas policy enforcement, and retry/backoff strategies. The Relayer relies on Web3J for encoding, signing, and broadcasting transactions over JSON-RPC.

In the prototype, these capabilities are abstracted as a RelayerHelper. This helper receives unsigned payloads from the Backend API, obtains the signing key via WalletConfigHelper, signs them, and uses Web3J to submit them directly to the RPC node. In the next phase, the helper will evolve into a dedicated service, enabling horizontal scalability, centralized nonce queues, and clearer separation between orchestration (Backend API) and execution (Relayer).


4.2.2.9 Smart Contracts

Smart contracts define the on-chain business logic that governs issuance, transfers, and settlements. They encapsulate the rules for token lifecycle management, validation of participants, and enforcement of workflows such as atomic swaps. The Backend API interacts with these contracts via ABI-encoded function calls submitted as signed transactions.

In the prototype, contracts are deployed on the Linea L2 test environment, with interaction handled directly by the Backend API. In future phases, these contracts will integrate more tightly with Relayer Services and Event Listeners to enable richer orchestration and monitoring.

⸻

4.2.2.10 Contract Bridges

Bridges provide interoperability between the platform and external networks, such as SWIFT or other DLT ecosystems. They act as a trusted relay for data and asset transfers, ensuring that events in one domain are consistently reflected in another. The Bridge component validates external attestations, manages acknowledgements, and enforces regulatory compliance.

In the prototype, bridging logic is abstracted using a BridgeHelper inside the Backend API, returning mock responses. The actual bridge implementation will be added in the next phase to support secure cross-network transaction settlement.

⸻

4.2.2.11 Gas Fee Responsibility

All on-chain operations require gas to be executed on the blockchain. Responsibility for gas payment depends on the architecture: in the prototype, the Backend API directly signs and submits transactions using a dedicated service account, which covers the gas cost. This ensures predictable testing without requiring participants to manage their own gas balances.

In the next phase, the Relayer Service will manage gas sponsorship more explicitly. It may implement a sponsored transaction model, where the Relayer pays gas on behalf of users, or enforce a quota model, where participants deposit funds in advance. This abstraction ensures that business actors (Issuer, Buyer, Bank) are shielded from direct gas management, while still allowing governance rules to define cost allocation

4.2.2.3 Relayer Service (Next Phase)

The Relayer Service is responsible for nonce-safe submission of signed transactions to the blockchain, implementing retry strategies, gas sponsorship, and idempotency. It acts as a controlled gateway to the blockchain, decoupling transaction submission from backend logic.

In the prototype, this functionality is represented by a RelayerHelper within the Backend API. This helper signs transactions via KMS and submits them directly to the node. In the next phase, the helper will be replaced by a standalone service to improve scalability and resilience.

⸻

4.2.2.4 Event Listener / Indexer (Next Phase)

The Event Listener subscribes to contract events and normalizes them into application-friendly formats. It updates the backend with confirmations, state changes, and derived business events. This allows the system to replace ad-hoc polling with structured event processing.

For the prototype, event consumption is abstracted through an EventReaderHelper that queries receipts or logs directly from the blockchain. In the next phase, the Event Listener will be deployed as a dedicated service, ensuring real-time synchronization between on-chain state and backend persistence.

⸻

4.2.2.5 Notification Service (Next Phase)

The Notification Service delivers outbound alerts to stakeholders via email, SMS, or webhooks, triggered by specific business events such as transaction settlement or contract state changes. This improves transparency and user engagement across participants.

In the prototype, notifications are mocked through a NotificationHelper inside the Backend API. This allows the system to demonstrate workflows without requiring external delivery channels, while still maintaining consistent interfaces for future integration.

⸻

4.2.2.6 Bridge Connector (Next Phase)

The Bridge Connector enables interoperability between the blockchain platform and external networks (e.g., SWIFT integration). It validates cross-domain operations, manages attestations, and ensures consistency of settlement information across systems.

For the prototype, this component is abstracted using a BridgeHelper that returns deterministic mock responses. In future phases, the connector will be implemented as a secure microservice, handling real cross-network communication and regulatory compliance requirements.

⸻

4.2.2.7 KMS Integration

The Key Management Service (KMS) provides secure custody of cryptographic keys used for signing transactions. The Backend API interacts with KMS over HTTPS, ensuring private keys never leave the secure enclave. This enhances security and compliance for sensitive financial operations.

KMS is fully integrated in the prototype, supporting signing requests initiated by the Backend API. This integration remains unchanged across phases, forming the foundation of secure transaction execution.

⸻

4.2.2.8 Database

A relational database (e.g., PostgreSQL) serves as the system of record for off-chain data, including user requests, transaction metadata, mappings, and audit logs. The Backend API ensures consistent writes and supports query interfaces for reporting and monitoring.

The database is already part of the prototype and will remain central to subsequent phases. Future improvements may include event-sourced projections populated by the Event Listener, enriching the read model with real-time on-chain updates
